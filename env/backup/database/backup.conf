# Database Backup Configuration

# Database type (mariadb)
DB_TYPE="mariadb"

# Database credentials
DB_USER="nextcloud"
DB_PASS="your_secure_password"
DB_NAME="nextcloud"
DB_HOST="localhost"

# Backup options
BACKUP_FILENAME="${DB_NAME}_$(date +%Y%m%d_%H%M%S).sql"
COMPRESS_BACKUP=true

# Cloud sync settings
CLOUD_SYNC=true
CLOUD_PROVIDER="r2"
R2_BUCKET="your-bucket-name"
R2_ENDPOINT="https://your-account-id.r2.cloudflarestorage.com"

# Retention policy (in days)
RETENTION_DAYS=30

# Pre-backup steps
pre_backup() {
    print_status "Starting database backup..."
    
    # Check if database is running
    if ! systemctl is-active --quiet ${DB_TYPE}.service; then
        print_error "Database service is not running"
        exit 1
    fi
    
    # Check if we can connect to the database
    if [ "$DB_TYPE" = "mysql" ]; then
        if ! mysql -u "$DB_USER" -p"$DB_PASS" -h "$DB_HOST" -e "USE $DB_NAME;" 2>/dev/null; then
            print_error "Cannot connect to MySQL database"
            exit 1
        fi
    else
        if ! PGPASSWORD="$DB_PASS" psql -U "$DB_USER" -h "$DB_HOST" -d "$DB_NAME" -c "\q" 2>/dev/null; then
            print_error "Cannot connect to PostgreSQL database"
            exit 1
        fi
    fi
}

# Perform the actual backup
perform_backup() {
    local backup_file="$BACKUP_DIR/$BACKUP_FILENAME"
    
    print_status "Backing up $DB_TYPE database: $DB_NAME"
    
    if [ "$DB_TYPE" = "mysql" ]; then
        # MySQL/MariaDB backup
        mysqldump --single-transaction --quick --lock-tables=false \
            -u "$DB_USER" -p"$DB_PASS" -h "$DB_HOST" "$DB_NAME" > "$backup_file"
    else
        # PostgreSQL backup
        PGPASSWORD="$DB_PASS" pg_dump -U "$DB_USER" -h "$DB_HOST" "$DB_NAME" > "$backup_file"
    fi
    
    # Check if backup was successful
    if [ ! -s "$backup_file" ]; then
        print_error "Backup file is empty. Backup may have failed."
        exit 1
    fi
    
    # Compress the backup if enabled
    if [ "$COMPRESS_BACKUP" = true ]; then
        print_status "Compressing backup..."
        gzip "$backup_file"
        backup_file="${backup_file}.gz"
    fi
    
    print_success "Database backup created: $backup_file"
    
    # Store the backup path for post-backup hooks
    BACKUP_FILE="$backup_file"
}

# Post-backup steps
post_backup() {
    # Verify the backup
    if [ "$COMPRESS_BACKUP" = true ]; then
        if ! gzip -t "$BACKUP_FILE"; then
            print_error "Backup file is corrupted: $BACKUP_FILE"
            exit 1
        fi
    fi
    
    # Calculate backup size
    local size=$(du -h "$BACKUP_FILE" | cut -f1)
    print_status "Backup size: $size"
    
    # Update latest backup symlink
    ln -sf "$BACKUP_FILE" "$(dirname "$BACKUP_FILE")/latest.${BACKUP_FILE##*.}"
}

# Verify backup integrity
verify_backup_integrity() {
    local backup_path="$1"
    
    if [ ! -s "$backup_path" ]; then
        print_error "Backup file is empty: $backup_path"
        return 1
    fi
    
    if [[ "$backup_path" == *.gz ]]; then
        if ! gzip -t "$backup_path"; then
            print_error "Compressed backup is corrupted: $backup_path"
            return 1
        fi
    fi
    
    # For MySQL, we can check if the dump contains valid SQL
    if [[ "$DB_TYPE" == "mysql" && "$backup_path" != *.gz ]]; then
        if ! head -n 10 "$backup_path" | grep -q "^-- MySQL dump"; then
            print_error "Invalid MySQL dump file: $backup_path"
            return 1
        fi
    fi
    
    return 0
}
